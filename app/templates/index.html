<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workhorse - Solana Trading Bot</title>
    
    <!-- CSS -->
    <style>
        :root {
            --primary: #14f195;
            --primary-dark: #00d182;
            --secondary: #8b5cf6;
            --background: #0f0f23;
            --surface: #1a1a3e;
            --surface-light: #242454;
            --text: #ffffff;
            --text-muted: #a0a0b8;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --border: #2d2d5f;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }
        
        header {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 1rem 0;
            margin-bottom: 2rem;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        h1 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        .status-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-left: 0.5rem; /* Add spacing between badges */
        }
        
        .status-running { background: var(--success); color: white; }
        .status-stopped { background: var(--error); color: white; }
        .status-paper { background: var(--warning); color: black; }
        
        /* Badges for arbitrage section */
        .badge {
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }
        
        .badge-success { background: var(--success); color: white; }
        .badge-info { background: var(--secondary); color: white; }
        .badge-warning { background: var(--warning); color: black; }
        
        /* Settings button for mode switching */
        .settings-btn {
            background: var(--surface-light);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.75rem;
            margin-left: 0.5rem;
            transition: all 0.2s;
        }
        
        .settings-btn:hover {
            background: var(--border);
        }
        
        /* Wallet info in header */
        .wallet-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-right: 1rem;
        }
        
        .wallet-address {
            font-family: monospace;
            font-size: 0.7rem;
        }
        
        .wallet-balance {
            font-weight: 600;
            color: var(--primary);
        }
        
        .wallet-pnl {
            font-weight: 600;
            color: var(--success);
        }
        
        .wallet-pnl.negative {
            color: var(--error);
        }
        
        /* Grid System */
        .grid {
            display: grid;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .grid-cols-1 { grid-template-columns: 1fr; }
        .grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
        .grid-cols-3 { grid-template-columns: repeat(3, 1fr); }
        .grid-cols-4 { grid-template-columns: repeat(4, 1fr); }
        
        /* Portfolio & Trades Grid Layout */
        .portfolio-trades-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        /* Arbitrage Trades Full Width */
        .arbitrage-trades-section {
            margin-bottom: 2rem;
        }
        
        /* Table Container Improvements */
        .table-container {
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            background: var(--background);
            overflow: hidden;
        }
        
        .table-container.recent-trades {
            max-height: 250px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .table-container.arbitrage-trades {
            max-height: 400px;
            overflow-y: auto;
            overflow-x: auto;
        }
        
        /* Enhanced Table Styles */
        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            background: var(--background);
            font-size: 0.875rem;
        }
        
        .table th {
            background: var(--surface);
            color: var(--text);
            font-weight: 600;
            text-align: left;
            padding: 0.75rem 1rem;
            border-bottom: 2px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            vertical-align: middle;
        }
        
        .table tbody tr:hover {
            background: var(--surface);
        }
        
        .table tbody tr:last-child td {
            border-bottom: none;
        }
        
        /* Table responsive adjustments */
        .table th:first-child,
        .table td:first-child {
            padding-left: 1.25rem;
        }
        
        .table th:last-child,
        .table td:last-child {
            padding-right: 1.25rem;
        }
        
        /* Status indicators in tables */
        .table .status-success {
            color: var(--success);
            font-weight: 600;
        }
        
        .table .status-error {
            color: var(--error);
            font-weight: 600;
        }
        
        .table .text-muted {
            color: var(--text-muted);
        }
        
        .table .text-center {
            text-align: center;
        }
        
        /* Responsive Tables */
        @media (max-width: 1200px) {
            .portfolio-trades-grid {
                grid-template-columns: 1fr;
            }
            
            .table-container.arbitrage-trades {
                overflow-x: auto;
            }
            
            .grid-cols-3 {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .table-container.recent-trades,
            .table-container.arbitrage-trades {
                max-height: 300px;
            }
            
            .grid-cols-2 {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            overflow: hidden;
        }
        
        .card-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border);
            background: var(--background);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .card-header h2 {
            margin: 0;
        }
        
        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            margin: 0;
        }
        
        /* For metric cards and cards without tables */
        .card.metric {
            padding: 1.5rem;
            text-align: center;
        }
        
        .card.metric .card-header {
            padding: 0;
            border-bottom: none;
            background: transparent;
            margin-bottom: 1rem;
        }
        
        /* Cards with just content (no tables) */
        .card.content-only {
            padding: 1.5rem;
        }
        
        .card.content-only .card-header {
            padding: 0;
            border-bottom: none;
            background: transparent;
            margin-bottom: 1rem;
        }
        
        .metric {
            text-align: center;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        .metric-label {
            font-size: 0.875rem;
            color: var(--text-muted);
        }
        
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--primary);
            color: var(--background);
        }
        
        .btn-primary:hover {
            background: var(--primary-dark);
        }
        
        .btn-secondary {
            background: var(--surface-light);
            color: var(--text);
            border: 1px solid var(--border);
        }
        
        .btn-success {
            background: var(--success);
            color: white;
        }
        
        .btn-success:hover {
            background: #059669;
        }
        
        .btn-danger {
            background: var(--error);
            color: white;
        }
        
        .btn-danger:hover {
            background: #dc2626;
        }
        
        .btn-disabled {
            background: #6b7280 !important;
            color: #9ca3af !important;
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }
        
        .btn-disabled:hover {
            background: #6b7280 !important;
            color: #9ca3af !important;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--card-radius, 0.75rem);
            max-width: 600px;
            width: 90%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .modal-header h3 {
            margin: 0;
            color: var(--error);
        }
        
        .close-btn {
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            transition: color 0.2s;
        }
        
        .close-btn:hover {
            color: var(--text);
        }
        
        .modal-body {
            padding: 1.5rem;
        }
        
        .alert-details {
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
            margin: 1rem 0;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .alert-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        .alert-actions .btn {
            flex: 1;
        }
        
        /* Notification Styles */
        #notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 999;
            max-width: 400px;
        }
        
        .notification {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            animation: slideIn 0.3s ease-out;
        }
        
        .notification.error {
            border-left: 4px solid var(--error);
        }
        
        .notification.warning {
            border-left: 4px solid var(--warning);
        }
        
        .notification.success {
            border-left: 4px solid var(--success);
        }
        
        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .notification-title {
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .notification-close {
            cursor: pointer;
            color: var(--text-muted);
            font-size: 1.2rem;
        }
        
        .notification-message {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <!-- Toast notifications container -->
    <div class="toast-container" id="toast-container"></div>
    
    <header>
        <div class="container">
            <div class="header-content">
                <h1>🐎 Workhorse</h1>
                
                <!-- Wallet Portfolio Info -->
                <div class="wallet-info">
                    <div class="wallet-address" id="wallet-address">Wallet: --</div>
                    <div class="wallet-balance" id="wallet-balance">Balance: --</div>
                    <div class="wallet-pnl" id="wallet-pnl">PnL: --</div>
                </div>
                
                <!-- Status and Mode Controls -->
                <div style="display: flex; align-items: center;">
                    <span id="status-badge" class="status-badge status-stopped">Initializing</span>
                    <button class="settings-btn" onclick="toggleTradingMode()" title="Switch between Paper and MainNet mode">
                        ⚙️ <span id="mode-text">PAPER</span>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <!-- Key Metrics -->
        <div class="grid grid-cols-3">
            <div class="card metric">
                <div class="metric-value" id="portfolio-value">--</div>
                <div class="metric-label">Portfolio Value</div>
            </div>
            <div class="card metric">
                <div class="metric-value" id="total-pnl">--</div>
                <div class="metric-label">Total P&L</div>
            </div>
            <div class="card metric">
                <div class="metric-value" id="uptime">--</div>
                <div class="metric-label">Uptime</div>
            </div>
        </div>

        <!-- Status and Refresh -->
        <div class="card content-only">
            <div class="card-header">
                <h2 class="card-title">Arbitrage Bot Status</h2>
                <div id="connection-status" class="text-muted">
                    <span class="loading"></span> Connecting...
                </div>
            </div>
            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                <button id="start-bot" class="btn btn-success" onclick="startBot()" style="display: none;">
                    ▶️ Start Bot
                </button>
                <button id="stop-bot" class="btn btn-error" onclick="stopBot()" style="display: none;">
                    ⏹️ Stop Bot
                </button>
                <button id="refresh-data" class="btn btn-primary" onclick="refreshData()">
                    Refresh Data
                </button>
                <button id="check-funds" class="btn btn-secondary" onclick="checkFunds()">
                    🔍 Check Funds
                </button>
                <button id="fund-wallet" class="btn btn-success" onclick="showWalletQR()">
                    💰 Fund Wallet
                </button>
            </div>
        </div>
            <style>
                /* Tooltip styles */
                .tooltip {
                    position: relative;
                    display: inline-flex;
                    align-items: center;
                    margin-left: 5px;
                    cursor: help;
                }
                
                .tooltip:hover::after {
                    content: attr(data-tooltip);
                    position: absolute;
                    left: 50%;
                    transform: translateX(-50%);
                    bottom: 100%;
                    background-color: rgba(13, 17, 47, 0.95);
                    color: #fff;
                    text-align: left;
                    border-radius: 4px;
                    padding: 8px 12px;
                    width: max-content;
                    max-width: 350px;
                    z-index: 100;
                    font-size: 0.85rem;
                    white-space: normal;
                    border: 1px solid var(--error);
                    box-shadow: 0 3px 15px rgba(0, 0, 0, 0.4);
                    margin-bottom: 8px;
                    line-height: 1.5;
                    word-break: break-word;
                }
                
                .info-icon {
                    width: 16px;
                    height: 16px;
                    color: var(--error);
                    filter: drop-shadow(0 0 2px rgba(239, 68, 68, 0.3));
                }
                
                /* Trade row with error styling */
                tr.has-error {
                    background-color: rgba(239, 68, 68, 0.05);
                    transition: all 0.2s;
                    border-left: 2px solid var(--error);
                }
                
                tr.has-error:hover {
                    background-color: rgba(239, 68, 68, 0.1);
                    transform: translateX(2px);
                }
                
                /* Badge styles for error */
                .badge-error {
                    background-color: var(--error);
                    color: white;
                }
                
                /* Animation for failed trades */
                @keyframes highlight-error {
                    0% { background-color: rgba(239, 68, 68, 0); }
                    50% { background-color: rgba(239, 68, 68, 0.2); }
                    100% { background-color: rgba(239, 68, 68, 0.05); }
                }
                
                tr.has-error.new-error {
                    animation: highlight-error 1.5s ease-out;
                }
                
                /* Animation for successful trades */
                @keyframes highlight-success {
                    0% { background-color: rgba(20, 241, 149, 0); }
                    50% { background-color: rgba(20, 241, 149, 0.15); }
                    100% { background-color: rgba(20, 241, 149, 0); }
                }
                
                tr.new-success {
                    animation: highlight-success 1.5s ease-out;
                }
            </style>
            </div>
        </div>

        <!-- Portfolio & Recent Trades -->
        <div class="portfolio-trades-grid">
            <!-- Portfolio -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Portfolio</h2>
                </div>
                <div style="padding: 1.5rem;">
                    <table class="table">
                        <tbody>
                            <tr>
                                <td>USD Balance</td>
                                <td id="usd-balance">--</td>
                            </tr>
                            <tr>
                                <td>SOL Balance</td>
                                <td id="sol-balance">--</td>
                            </tr>
                            <tr>
                                <td>Total Value</td>
                                <td id="total-value">--</td>
                            </tr>
                            <tr>
                                <td>Unrealized P&L</td>
                                <td id="unrealized-pnl">--</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Recent Trades -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Recent Trades</h2>
                </div>
                <div class="table-container recent-trades">
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Time</th>
                                <th>Action</th>
                                <th>Amount</th>
                                <th>Price</th>
                            </tr>
                        </thead>
                        <tbody id="trades-table">
                            <tr>
                                <td colspan="4" class="text-muted text-center">No trades yet</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Arbitrage Trades Section -->
        <div class="card arbitrage-trades-section">
            <div class="card-header">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <svg style="width: 24px; height: 24px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M15 10l5 5-5 5"></path>
                        <path d="M4 4v7a4 4 0 0 0 4 4h12"></path>
                        <path d="M9 14l-5-5 5-5"></path>
                        <path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>
                    </svg>
                    <h2 class="card-title">Arbitrage Trades</h2>
                    <button id="test-trades-btn" class="btn btn-secondary" style="margin-left: auto; padding: 4px 8px; font-size: 12px;" onclick="injectTestTrades()">
                        🧪 Test Trades
                    </button>
                </div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 0.5rem;">
                    <span id="arbitrage-profit" class="badge badge-success" style="display: flex; align-items: center;">
                        <svg style="width: 16px; height: 16px; margin-right: 4px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path>
                        </svg>
                        Total Profit: $0.00
                    </span>
                    <span id="arbitrage-count" class="badge badge-info" style="display: flex; align-items: center;">
                        <svg style="width: 14px; height: 14px; margin-right: 4px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 3v18h18"></path>
                            <path d="M18 17V9"></path>
                            <path d="M13 17V5"></path>
                            <path d="M8 17v-3"></path>
                        </svg>
                        Trades: 0
                    </span>
                    <span id="arbitrage-success-rate" class="badge badge-warning" style="display: flex; align-items: center;">
                        <svg style="width: 14px; height: 14px; margin-right: 4px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                            <path d="M22 4L12 14.01l-3-3"></path>
                        </svg>
                        Success Rate: 0%
                    </span>
                </div>
            </div>
            <div class="table-container arbitrage-trades">
                <table class="table">
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Pair</th>
                            <th>Buy DEX</th>
                            <th>Sell DEX</th>
                            <th>Amount</th>
                            <th>Profit</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="arbitrage-trades-table">
                        <tr>
                            <td colspan="7" class="text-muted text-center">No arbitrage trades yet</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

    </div>

    <!-- Funds Alert Modal -->
    <div id="funds-alert-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="alert-title">⚠️ Insufficient Funds</h3>
                <span class="close-btn" onclick="closeFundsAlert()">&times;</span>
            </div>
            <div class="modal-body">
                <div id="alert-message"></div>
                <div id="alert-details" class="alert-details"></div>
                <div class="alert-actions">
                    <button class="btn btn-primary" onclick="window.open('MAINNET_GUIDE.md', '_blank')">
                        📖 View Funding Guide
                    </button>
                    <button class="btn btn-secondary" onclick="closeFundsAlert()">
                        Dismiss
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Wallet QR Code Modal -->
    <div id="wallet-qr-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>💰 Fund Your Wallet</h3>
                <span class="close-btn" onclick="closeWalletQR()">&times;</span>
            </div>
            <div class="modal-body">
                <div style="text-align: center;">
                    <p><strong>Send SOL or USDT to this address:</strong></p>
                    <div id="wallet-address-display" style="background: var(--surface-light); padding: 1rem; border-radius: 8px; margin: 1rem 0; font-family: monospace; word-break: break-all; border: 1px solid var(--border);">
                        Loading...
                    </div>
                    <div id="qr-code-container" style="display: flex; justify-content: center; margin: 1.5rem 0;">
                        <!-- QR code will be generated here -->
                    </div>
                    <div style="margin-top: 1rem;">
                        <button class="btn btn-secondary" onclick="copyWalletAddress()">
                            📋 Copy Address
                        </button>
                        <button class="btn btn-primary" onclick="checkFunds(); closeWalletQR();">
                            🔍 Check Balance
                        </button>
                    </div>
                    <div style="margin-top: 1rem; font-size: 0.9rem; color: var(--text-muted);">
                        <p><strong>Supported tokens:</strong></p>
                        <p>• SOL (for transaction fees)</p>
                        <p>• USDT (for trading)</p>
                        <p>• USDC (for trading)</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notification-container"></div>

    <!-- Socket.IO -->
    <!-- JavaScript Libraries -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    
    <script>
        // Error handling
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('JavaScript Error:', msg, 'at', url + ':' + lineNo + ':' + columnNo);
            return false;
        };
        
        // Current price functionality
        function getCurrentPrice() {
            fetch('/api/price')
                .then(response => response.json())
                .then(data => {
                    if (data && data.price) {
                        console.log(`Current price updated: $${data.price}`);
                    }
                })
                .catch(error => {
                    console.error('Error fetching current price:', error);
                });
        }
        
        // Simple debug function that just checks the price API
        function debugPrice() {
            fetch('/api/price')
                .then(response => response.json())
                .then(data => {
                    console.log('Price API debug:', data);
                    alert(`Current SOL price: $${data.price ? parseFloat(data.price).toFixed(2) : 'N/A'}`);
                })
                .catch(error => {
                    console.error('Debug error:', error);
                    alert('Error debugging price: ' + error);
                });
        }

        // Trading mode toggle
        let currentMode = 'paper'; // Default to paper mode
        
        function toggleTradingMode() {
            currentMode = currentMode === 'paper' ? 'mainnet' : 'paper';
            const modeText = document.getElementById('mode-text');
            const settingsBtn = document.querySelector('.settings-btn');
            
            if (currentMode === 'mainnet') {
                modeText.textContent = 'MAINNET';
                settingsBtn.style.background = 'var(--error)';
                settingsBtn.style.color = 'white';
                settingsBtn.style.borderColor = 'var(--error)';
            } else {
                modeText.textContent = 'PAPER';
                settingsBtn.style.background = 'var(--surface-light)';
                settingsBtn.style.color = 'var(--text)';
                settingsBtn.style.borderColor = 'var(--border)';
            }
            
            console.log('Trading mode switched to:', currentMode.toUpperCase());
            
            // Here you would typically send the mode change to the backend
            // fetch('/api/trading/mode', {
            //     method: 'POST',
            //     headers: { 'Content-Type': 'application/json' },
            //     body: JSON.stringify({ mode: currentMode })
            // });
        }
        
        // No trading controls needed - arbitrage bot runs automatically
        
        // Request initial data function
        function requestUpdate() {
            if (typeof socket !== 'undefined' && socket.connected) {
                console.log('🚀 Emitting request_update');
                socket.emit('request_update');
            }
        }

        let isTradingActive = false;
        // Trading button removed - arbitrage bot runs automatically
        const statusBadge = document.getElementById('status-badge');

        function startTrading() {
            console.log('▶️ Attempting to start trading...');
            if (typeof socket !== 'undefined' && socket.connected) {
                socket.emit('start_trading');
                // Optimistically update UI, backend will confirm
                // updateTradingStatus(true, 'Starting...'); 
                // Let backend confirm status via 'status_update' or specific ack
            } else {
                console.error('❌ Socket not connected, cannot start trading.');
                alert('Not connected to server. Cannot start trading.');
            }
        }

        function stopTrading() {
            console.log('🛑 Attempting to stop trading...');
            if (typeof socket !== 'undefined' && socket.connected) {
                socket.emit('stop_trading');
                // Optimistically update UI, backend will confirm
                // updateTradingStatus(false, 'Stopping...');
            } else {
                console.error('❌ Socket not connected, cannot stop trading.');
                alert('Not connected to server. Cannot stop trading.');
            }
        }

        function updateTradingStatus(isActive, currentStatusText = null) {
            isTradingActive = isActive;
            const startBtn = document.getElementById('start-bot');
            const stopBtn = document.getElementById('stop-bot');
            
            // Update status badge
            if (statusBadge) {
                if (currentStatusText) {
                    statusBadge.textContent = currentStatusText;
                    
                    // Set appropriate class based on status
                    statusBadge.className = 'status-badge '; // Reset classes
                    if (currentStatusText.toLowerCase() === 'running') {
                        statusBadge.classList.add('status-running');
                    } else if (currentStatusText.toLowerCase() === 'stopped') {
                        statusBadge.classList.add('status-stopped');
                    } else if (currentStatusText.toLowerCase() === 'starting') {
                        statusBadge.classList.add('status-running'); // Use running style for starting
                    } else if (currentStatusText.toLowerCase() === 'stopping') {
                        statusBadge.classList.add('status-stopped'); // Use stopped style for stopping
                    } else {
                        statusBadge.classList.add('status-stopped'); // Default to stopped
                    }
                } else {
                    statusBadge.textContent = isTradingActive ? 'Running' : 'Stopped';
                    statusBadge.className = 'status-badge '; // Reset classes
                    statusBadge.classList.add(isTradingActive ? 'status-running' : 'status-stopped');
                }
            }
            
            // Update button visibility based on actual status
            if (startBtn && stopBtn) {
                const status = currentStatusText ? currentStatusText.toLowerCase() : (isTradingActive ? 'running' : 'stopped');
                
                if (status === 'running') {
                    // Bot is running - show stop button
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-block';
                    stopBtn.disabled = false;
                    stopBtn.innerHTML = '⏹️ Stop Bot';
                } else if (status === 'stopped') {
                    // Bot is stopped - show start button
                    startBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'none';
                    startBtn.disabled = false;
                    startBtn.innerHTML = '▶️ Start Bot';
                } else if (status === 'starting') {
                    // Bot is starting - show stop button (disabled) and hide start
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-block';
                    stopBtn.disabled = true; // Disable while starting
                    stopBtn.innerHTML = '⏳ Starting...';
                } else if (status === 'stopping') {
                    // Bot is stopping - show start button (disabled) and hide stop
                    startBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'none';
                    startBtn.disabled = true; // Disable while stopping
                    startBtn.innerHTML = '⏳ Stopping...';
                }
            }
            
            console.log(`Trading status updated: Active = ${isTradingActive}, Status = ${currentStatusText}, Badge = ${statusBadge.textContent}`);
        }
        
        // Initialize Socket.IO connection
        // Auto-detect protocol (http vs https) and host from current page URL
        const protocol = window.location.protocol;
        const hostname = window.location.hostname;
        const port = window.location.port || (protocol === 'https:' ? 443 : 80);
        const socketUrl = `${protocol}//${hostname}:${port}`;
        
        console.log(`Connecting to Socket.IO at ${socketUrl}`);
        
        var socket = io(socketUrl, {
            transports: ['websocket', 'polling'], // Try WebSocket first, fallback to polling
            rejectUnauthorized: false, // Allow self-signed certificates
            secure: protocol === 'https:', // Enable secure flag for HTTPS
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            timeout: 20000
        });

        socket.on('connect', () => {
            console.log('🔗 Socket.IO connected!');
            document.getElementById('connection-status').innerHTML = '<span style=\"color: var(--success);\">●</span> Connected';
            
            // Ensure status badge gets updated from initializing state
            if (statusBadge.textContent === "Initializing") {
                statusBadge.textContent = "Connected";
                statusBadge.className = 'status-badge status-stopped';
            }
            
            requestUpdate(); // Request initial data (including wallet and trading status)
        });
        
        socket.on('disconnect', () => {
            console.log('🔌 Socket.IO disconnected!');
            document.getElementById('connection-status').innerHTML = '<span style=\"color: var(--error);\">●</span> Disconnected';
            updateTradingStatus(false, 'Disconnected'); // Assume trading stops if disconnected
            statusBadge.className = 'status-badge status-stopped';
        });
        
        socket.on('connect_error', (err) => {
            console.error('🔗 Socket.IO connection error:', err);
            document.getElementById('connection-status').innerHTML = '<span style=\"color: var(--error);\">●</span> Connection Failed';
            updateTradingStatus(false, 'Error');
            statusBadge.className = 'status-badge status-stopped';
        });

        // Debug: Log ALL incoming Socket.IO events
        socket.onAny((eventName, ...args) => {
            console.log('🔔 Socket.IO event received:', eventName, args);
        });

        socket.on('price_update', function(data) {
            console.log('📈 Received price_update:', data);
            // Price display has been removed from UI
            // Request a status update to ensure we get the latest state
            if (socket && socket.connected) {
                console.log('📊 Requesting status update after price update');
                socket.emit('request_update');
            }
        });
        
        socket.on('status_update', function(data) {
            console.log('ℹ️ Received status_update data from backend:', data); // Log the whole data object

            if (data.status) {
                const isActive = data.status.toLowerCase() === 'running';
                updateTradingStatus(isActive, data.status);
                // The updateTradingStatus function now handles button visibility and classes
            }
            if (data.mode) {
                currentMode = data.mode.toLowerCase();
                const modeText = document.getElementById('mode-text');
                const settingsBtn = document.querySelector('.settings-btn');
                if (currentMode === 'mainnet') {
                    modeText.textContent = 'MAINNET';
                    settingsBtn.style.background = 'var(--error)';
                    settingsBtn.style.color = 'white';
                    settingsBtn.style.borderColor = 'var(--error)';
                } else {
                    modeText.textContent = 'PAPER';
                    settingsBtn.style.background = 'var(--surface-light)';
                    settingsBtn.style.color = 'var(--text)';
                    settingsBtn.style.borderColor = 'var(--border)';
                }
            }
            // Update other status elements as needed
            if (data.portfolio_value !== undefined) {
                document.getElementById('total-value').textContent = `$${parseFloat(data.portfolio_value).toFixed(2)}`;
            }
            if (data.total_pnl !== undefined) {
                const pnlElement = document.getElementById('unrealized-pnl');
                const pnlValue = parseFloat(data.total_pnl);
                pnlElement.textContent = `$${pnlValue.toFixed(2)}`;
                pnlElement.className = pnlValue >= 0 ? 'text-success' : 'text-error';
            }
            if (data.uptime) {
                document.getElementById('uptime').textContent = data.uptime;
            }
            
            // Update portfolio balances from wallet info
            if (data.wallet_info && data.wallet_info.balance !== undefined) {
                // For paper mode, show paper trading balance
                if (data.mode === 'paper') {
                    const paperBalance = parseFloat(data.portfolio_value || 0);
                    document.getElementById('usd-balance').textContent = `$${paperBalance.toFixed(2)}`;
                    document.getElementById('sol-balance').textContent = '0.00 SOL (Paper Mode)';
                } else {
                    // For live mode, get actual balances
                    document.getElementById('sol-balance').textContent = `${parseFloat(data.wallet_info.balance || 0).toFixed(4)} SOL`;
                    // We'll need to get USDT balance separately - for now show placeholder
                    document.getElementById('usd-balance').textContent = '$0.00 USDT';
                }
            } else {
                // Default values if no wallet info
                if (data.mode === 'paper') {
                    const paperBalance = parseFloat(data.portfolio_value || 0);
                    document.getElementById('usd-balance').textContent = `$${paperBalance.toFixed(2)}`;
                    document.getElementById('sol-balance').textContent = '0.00 SOL (Paper Mode)';
                } else {
                    document.getElementById('usd-balance').textContent = '$--';
                    document.getElementById('sol-balance').textContent = '-- SOL';
                }
            }
            
            if (data.wallet_info) {
                console.log('Wallet info received from backend via status_update:', data.wallet_info); // Specifically log wallet_info
                updateWalletInfo(data.wallet_info);
            } else {
                console.log('No wallet_info in received status_update data.');
            }
            
            // If we have recent trades data, populate the Recent Trades section
            if (data.recent_trades && Array.isArray(data.recent_trades)) {
                const tableBody = document.getElementById('trades-table');
                tableBody.innerHTML = '';
                
                if (data.recent_trades.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = '<td colspan="4" class="text-muted text-center">No trades yet</td>';
                    tableBody.appendChild(row);
                } else {
                    // Sort by timestamp (newest first) and update each trade
                    const sortedTrades = [...data.recent_trades].sort((a, b) => {
                        return new Date(b.timestamp || 0) - new Date(a.timestamp || 0);
                    });
                    
                    sortedTrades.forEach(trade => {
                        updateRecentTrades(trade);
                    });
                }
                
                // ALSO update the Arbitrage Trades panel with the same data
                // since recent_trades comes from the same source as arbitrage trades
                console.log('🔄 Also updating Arbitrage Trades panel from status_update');
                updateArbitrageTrades({
                    trades: data.recent_trades,
                    total_profit: data.total_pnl || 0,
                    trades_executed: data.trades_executed || 0,
                    successful_trades: data.recent_trades.filter(t => t.success).length
                });
            }
            
            // Update start button state after status changes
            setTimeout(updateStartButtonState, 100);
        });

        socket.on('trade_update', function(trade) {
            console.log('💱 Received trade_update:', trade);
            updateRecentTrades(trade);
        });
        
        // Update recent trades in the UI
        function updateRecentTrades(trade) {
            if (!trade) {
                console.log('No trade data available');
                return;
            }

            console.log('Processing trade for Recent Trades section:', trade);
            
            const tableBody = document.getElementById('trades-table');
            
            // If this is the first trade, clear the "No trades yet" message
            if (tableBody.innerHTML.includes('No trades yet')) {
                tableBody.innerHTML = '';
            }
            
            // Create a new row for this trade
            const row = document.createElement('tr');
            
            // Format the timestamp
            const tradeTime = new Date(trade.timestamp || Date.now());
            const timeFormatted = tradeTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
            
            // Determine action - for arbitrage trades
            let action, actionClass;
            
            if (trade.buy_source && trade.sell_source) {
                // It's an arbitrage trade
                action = `${trade.buy_source} → ${trade.sell_source}`;
                actionClass = 'text-info';
            } else if (trade.token_pair) {
                // It's a regular trade with a token pair
                action = `Arbitrage ${trade.token_pair}`;
                actionClass = 'text-info';
            } else {
                // Unknown trade type
                action = trade.action || 'Trade';
                actionClass = 'text-muted';
            }
            
            // Get amount - prefer trade_amount, fall back to amount or calculate from token_pair
            let amount;
            if (trade.trade_amount) {
                amount = parseFloat(trade.trade_amount);
            } else if (trade.amount) {
                amount = parseFloat(trade.amount);
            } else if (trade.token_pair) {
                // Just show the token pair as description
                amount = trade.token_pair;
            } else {
                amount = 'Unknown';
            }
            
            // Get price or profit information
            let price;
            if (trade.realized_profit !== undefined) {
                price = `Profit: ${parseFloat(trade.realized_profit).toFixed(4)} USDC`;
            } else if (trade.profit !== undefined) {
                price = `Profit: ${parseFloat(trade.profit).toFixed(4)} USDC`;
            } else if (trade.buy_price && trade.sell_price) {
                price = `${parseFloat(trade.buy_price).toFixed(4)} → ${parseFloat(trade.sell_price).toFixed(4)}`;
            } else {
                price = trade.price || 'N/A';
            }
            
            // Create the row HTML
            row.innerHTML = `
                <td>${timeFormatted}</td>
                <td class="${actionClass}">${action}</td>
                <td>${typeof amount === 'number' ? amount.toFixed(4) : amount}</td>
                <td>${typeof price === 'number' ? price.toFixed(4) : price}</td>
            `;
            
            // Insert at the beginning of the table (newest first)
            if (tableBody.firstChild) {
                tableBody.insertBefore(row, tableBody.firstChild);
            } else {
                tableBody.appendChild(row);
            }
            
            // Limit the number of displayed trades to prevent UI clutter
            const maxDisplayedTrades = 20;
            while (tableBody.children.length > maxDisplayedTrades) {
                tableBody.removeChild(tableBody.lastChild);
            }
        }
        
        // Data refresh function
        function refreshData() {
            console.log('🔄 Refreshing data...');
            requestUpdate();
        }
        
        // Funds validation function
        function checkFunds() {
            console.log('🔍 Checking funds...');
            const checkBtn = document.getElementById('check-funds');
            
            // Show loading state
            checkBtn.disabled = true;
            checkBtn.innerHTML = '⏳ Checking...';
            
            fetch('/api/validate-funds')
                .then(response => response.json())
                .then(data => {
                    console.log('Funds validation result:', data);
                    
                    // Create notification based on result
                    if (data.sufficient) {
                        if (data.warnings && data.warnings.length > 0) {
                            showNotification({
                                title: '⚠️ Funds Warning',
                                type: 'warning',
                                message: `Funds are sufficient but low: ${data.warnings.join(', ')}`
                            });
                        } else {
                            showNotification({
                                title: '✅ Funds Check',
                                type: 'success',
                                message: `Funds are sufficient. SOL: ${data.sol_balance || 'N/A'}, USDT: $${data.usdt_balance || 'N/A'}`
                            });
                        }
                    } else {
                        if (data.mode === 'paper') {
                            showNotification({
                                title: 'ℹ️ Paper Mode',
                                type: 'info',
                                message: 'Paper trading mode - no funds required'
                            });
                        } else {
                            // Show funds alert modal for serious issues
                            showFundsAlert({
                                type: 'manual_check',
                                severity: 'critical',
                                message: 'Insufficient funds detected',
                                details: data,
                                timestamp: new Date().toISOString()
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('Error checking funds:', error);
                    showNotification({
                        title: '❌ Error',
                        type: 'error',
                        message: 'Failed to check funds: ' + error.message
                    });
                })
                .finally(() => {
                    // Restore button state
                    checkBtn.disabled = false;
                    checkBtn.innerHTML = '🔍 Check Funds';
                });
        }
        
        // Expose functions to global scope for onclick handlers
        window.refreshData = refreshData;
        window.checkFunds = checkFunds;
        
        // Function to update start button state based on funds and bot status
        function updateStartButtonState() {
            const startBtn = document.getElementById('start-bot');
            const stopBtn = document.getElementById('stop-bot');
            
            if (!startBtn || !stopBtn) return;
            
            // Check if bot is running first
            fetch('/api/status')
                .then(response => response.json())
                .then(statusData => {
                    if (statusData.running) {
                        // Bot is running, show stop button
                        startBtn.style.display = 'none';
                        stopBtn.style.display = 'inline-block';
                        return;
                    }
                    
                    // Bot is stopped, show start button and check funds
                    startBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'none';
                    
                    // Check funds if in live mode
                    if (statusData.mode === 'live') {
                        return fetch('/api/validate-funds');
                    } else {
                        // Paper mode - always enable start button
                        startBtn.disabled = false;
                        startBtn.classList.remove('btn-disabled');
                        startBtn.title = '';
                        return null;
                    }
                })
                .then(response => {
                    if (!response) return null;
                    return response.json();
                })
                .then(fundsData => {
                    if (!fundsData) return; // Paper mode or already handled
                    
                    if (fundsData.sufficient) {
                        // Sufficient funds - enable start button
                        startBtn.disabled = false;
                        startBtn.classList.remove('btn-disabled');
                        if (fundsData.warnings && fundsData.warnings.length > 0) {
                            startBtn.title = `⚠️ Low funds: ${fundsData.warnings.join(', ')}`;
                        } else {
                            startBtn.title = '';
                        }
                    } else {
                        // Insufficient funds - disable start button
                        startBtn.disabled = true;
                        startBtn.classList.add('btn-disabled');
                        const issues = fundsData.issues || ['Insufficient funds'];
                        startBtn.title = `❌ Cannot start: ${issues.join(', ')}`;
                    }
                })
                .catch(error => {
                    console.error('Error updating start button state:', error);
                    // On error, disable the button to be safe
                    startBtn.disabled = true;
                    startBtn.classList.add('btn-disabled');
                    startBtn.title = '❌ Error checking funds';
                });
        }

        // Bot control functions
        function startBot() {
            console.log('🚀 Starting bot...');
            const startBtn = document.getElementById('start-bot');
            const stopBtn = document.getElementById('stop-bot');
            
            // Show loading state
            startBtn.disabled = true;
            startBtn.innerHTML = '⏳ Checking...';
            
            // First, validate funds if in live mode
            fetch('/api/validate-funds')
                .then(response => response.json())
                .then(fundsData => {
                    console.log('Funds validation before start:', fundsData);
                    
                    // If insufficient funds and in live mode, block start
                    if (fundsData.mode === 'live' && !fundsData.sufficient) {
                        showNotification({
                            title: '❌ Cannot Start Bot',
                            type: 'error',
                            message: 'Insufficient funds for live trading. Please fund your wallet first.'
                        });
                        
                        // Show detailed funds alert
                        showFundsAlert({
                            type: 'startup_blocked',
                            severity: 'critical',
                            message: 'Cannot start bot: insufficient funds',
                            details: fundsData,
                            timestamp: new Date().toISOString()
                        });
                        
                        // Restore button state
                        startBtn.disabled = false;
                        startBtn.innerHTML = '🚀 Start Bot';
                        return;
                    }
                    
                    // Funds are sufficient or we're in paper mode, proceed with start
                    startBtn.innerHTML = '⏳ Starting...';
                    
                    return fetch('/api/bot/start', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'}
                    });
                })
                .then(response => {
                    if (!response) return; // Funds check failed, already handled
                    return response.json();
                })
                .then(data => {
                    if (!data) return; // Funds check failed, already handled
                    
                    console.log('Bot start result:', data);
                    
                    if (data.success) {
                        showNotification({
                            title: '✅ Bot Started',
                            type: 'success',
                            message: 'Arbitrage bot started successfully'
                        });
                        
                        // Update status immediately to 'Starting' to show proper transition
                        updateTradingStatus(false, 'Starting');
                        
                        // Force status update via polling since WebSocket might be down
                        setTimeout(() => {
                            fetch('/api/status')
                                .then(response => response.json())
                                .then(statusData => {
                                    console.log('Manual status update after start:', statusData);
                                    // Update UI with latest status
                                    if (statusData.status) {
                                        updateTradingStatus(statusData.running, statusData.status);
                                    } else if (typeof statusData.running !== 'undefined') {
                                        updateTradingStatus(statusData.running, statusData.running ? 'Running' : 'Stopped');
                                    }
                                })
                                .catch(err => console.log('Status fetch failed:', err));
                        }, 500);
                        
                        // Request immediate status update through WebSocket if available
                        setTimeout(requestUpdate, 1000);
                    } else {
                        showNotification({
                            title: '❌ Start Failed',
                            type: 'error',
                            message: data.message || 'Failed to start bot'
                        });
                        
                        // Restore button state
                        startBtn.disabled = false;
                        startBtn.innerHTML = '🚀 Start Bot';
                    }
                })
                .catch(error => {
                    console.error('Error starting bot:', error);
                    showNotification({
                        title: '❌ Error',
                        type: 'error',
                        message: 'Failed to start bot: ' + error.message
                    });
                    
                    // Restore button state
                    startBtn.disabled = false;
                    startBtn.innerHTML = '🚀 Start Bot';
                });
        }
        
        function stopBot() {
            console.log('⏹️ Stopping bot...');
            const startBtn = document.getElementById('start-bot');
            const stopBtn = document.getElementById('stop-bot');
            
            // Show loading state
            stopBtn.disabled = true;
            stopBtn.innerHTML = '⏳ Stopping...';
            
            fetch('/api/bot/stop', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            })
                .then(response => response.json())
                .then(data => {
                    console.log('Bot stop result:', data);
                    
                    if (data.success) {
                        showNotification({
                            title: '⏹️ Bot Stopped',
                            type: 'info',
                            message: 'Arbitrage bot stopped successfully'
                        });
                        
                        // Update status immediately to 'Stopping' to show proper transition
                        updateTradingStatus(false, 'Stopping');
                        
                        // Force status update via polling since WebSocket might be down
                        setTimeout(() => {
                            fetch('/api/status')
                                .then(response => response.json())
                                .then(statusData => {
                                    console.log('Manual status update after stop:', statusData);
                                    // Update UI with latest status
                                    if (statusData.status) {
                                        updateTradingStatus(statusData.running, statusData.status);
                                    } else if (typeof statusData.running !== 'undefined') {
                                        updateTradingStatus(statusData.running, statusData.running ? 'Running' : 'Stopped');
                                    }
                                })
                                .catch(err => console.log('Status fetch failed:', err));
                        }, 500);
                        
                        // Request immediate status update through WebSocket if available
                        setTimeout(requestUpdate, 1000);
                    } else {
                        showNotification({
                            title: '❌ Stop Failed',
                            type: 'error',
                            message: data.error || 'Failed to stop bot'
                        });
                    }
                })
                .catch(error => {
                    console.error('Error stopping bot:', error);
                    showNotification({
                        title: '❌ Error',
                        type: 'error',
                        message: 'Failed to stop bot: ' + error.message
                    });
                })
                .finally(() => {
                    // Restore button state
                    stopBtn.disabled = false;
                    stopBtn.innerHTML = '⏹️ Stop Bot';
                });
        }
        
        // Expose bot control functions globally
        window.startBot = startBot;
        window.stopBot = stopBot;
        
        // Wallet QR Code functionality
        function showWalletQR() {
            console.log('🔍 Showing wallet QR code...');
            
            // Get wallet address from the dedicated API endpoint
            fetch('/api/wallet-address')
                .then(response => response.json())
                .then(data => {
                    if (!data.success || !data.address) {
                        showNotification({
                            title: '❌ Error',
                            type: 'error',
                            message: data.error || 'Could not retrieve wallet address'
                        });
                        return;
                    }
                    
                    const walletAddress = data.address;
                    
                    // Update the modal with wallet address
                    document.getElementById('wallet-address-display').textContent = walletAddress;
                    
                    // Generate QR code
                    generateQRCode(walletAddress);
                    
                    // Show the modal
                    document.getElementById('wallet-qr-modal').style.display = 'flex';
                })
                .catch(error => {
                    console.error('Error fetching wallet address:', error);
                    showNotification({
                        title: '❌ Error',
                        type: 'error',
                        message: 'Failed to get wallet address: ' + error.message
                    });
                });
        }
        
        function generateQRCode(address) {
            const container = document.getElementById('qr-code-container');
            container.innerHTML = ''; // Clear existing QR code
            
            // Create QR code using a simple approach (text-based for now)
            // In a production environment, you'd use a QR code library like qrcode.js
            
            // For now, create a simple QR code placeholder that links to a QR generator
            const qrSize = 200;
            const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=${qrSize}x${qrSize}&data=${encodeURIComponent(address)}`;
            
            const qrImg = document.createElement('img');
            qrImg.src = qrUrl;
            qrImg.alt = 'Wallet Address QR Code';
            qrImg.style.border = '1px solid var(--border)';
            qrImg.style.borderRadius = '8px';
            qrImg.style.maxWidth = '100%';
            qrImg.style.height = 'auto';
            
            // Add loading state
            qrImg.onload = () => {
                console.log('QR code loaded successfully');
            };
            qrImg.onerror = () => {
                console.error('Failed to load QR code');
                container.innerHTML = '<p style="color: var(--error);">Failed to generate QR code</p>';
            };
            
            container.appendChild(qrImg);
        }
        
        function copyWalletAddress() {
            const addressElement = document.getElementById('wallet-address-display');
            const address = addressElement.textContent;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(address).then(() => {
                    showNotification({
                        title: '✅ Copied',
                        type: 'success',
                        message: 'Wallet address copied to clipboard'
                    });
                }).catch(err => {
                    console.error('Failed to copy address:', err);
                    fallbackCopyTextToClipboard(address);
                });
            } else {
                fallbackCopyTextToClipboard(address);
            }
        }
        
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.position = "fixed";
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showNotification({
                        title: '✅ Copied',
                        type: 'success',
                        message: 'Wallet address copied to clipboard'
                    });
                } else {
                    showNotification({
                        title: '❌ Error',
                        type: 'error',
                        message: 'Failed to copy address'
                    });
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                showNotification({
                    title: '❌ Error',
                    type: 'error',
                    message: 'Copy to clipboard not supported'
                });
            }
            
            document.body.removeChild(textArea);
        }
        
        function closeWalletQR() {
            document.getElementById('wallet-qr-modal').style.display = 'none';
        }
        
        // Add to global scope
        window.showWalletQR = showWalletQR;
        window.copyWalletAddress = copyWalletAddress;
        window.closeWalletQR = closeWalletQR;
        
        // Update uptime periodically
        setInterval(async function() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                if (data.uptime) {
                    document.getElementById('uptime').textContent = data.uptime;
                }
            } catch (error) {
                console.error('Error fetching status:', error);
            }
        }, 60000);
        
        // Update start button state periodically (every 30 seconds)
        setInterval(function() {
            updateStartButtonState();
        }, 30000);
        
        // DOMContentLoaded event listener
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🎉 DOM fully loaded and parsed');
            
            // Initial call to set button state correctly
            updateTradingStatus(isTradingActive);
            
            // Initialize bot control button states (default to showing start button)
            const startBtn = document.getElementById('start-bot');
            const stopBtn = document.getElementById('stop-bot');
            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            
            // Update start button state based on funds
            setTimeout(updateStartButtonState, 500);
            
            // Request initial data which will update button states correctly
            setTimeout(requestUpdate, 1000); // Request update after a short delay
        });
        
        // Update wallet information
        function updateWalletInfo(walletData) {
            console.log('updateWalletInfo function called with:', walletData); // Log what the function receives
            if (!walletData) {
                console.error('updateWalletInfo called with no data or null/undefined walletData.');
                // Optionally, clear the fields or set to default
                document.getElementById('wallet-address').textContent = 'Wallet: --';
                document.getElementById('wallet-balance').textContent = 'Balance: --';
                document.getElementById('wallet-pnl').textContent = 'PnL: --';
                return;
            }
            
            const walletAddressEl = document.getElementById('wallet-address');
            const walletBalanceEl = document.getElementById('wallet-balance');
            const walletPnlEl = document.getElementById('wallet-pnl');
            
            if (walletData.address) {
                const truncatedAddress = walletData.address.slice(0, 4) + '...' + walletData.address.slice(-4);
                walletAddressEl.textContent = `Wallet: ${truncatedAddress}`;
            } else {
                walletAddressEl.textContent = 'Wallet: Not available';
                console.log('Wallet address missing in walletData');
            }
            
            // Log raw balance info for debugging
            console.log('Raw wallet balance data:', walletData.balance, 'typeof:', typeof walletData.balance);
            
            if (walletData.balance !== undefined && walletData.balance !== null) {
                try {
                    // Handle various formats: string, number, etc.
                    const balance = parseFloat(walletData.balance);
                    
                    if (!isNaN(balance)) {
                        if (balance === 0 || balance === 0.0) {
                            // Handle empty wallet case more gracefully
                            walletBalanceEl.textContent = `Balance: 0 SOL (Empty wallet)`;
                            console.log('Wallet has zero balance (empty wallet)');
                        } else {
                            walletBalanceEl.textContent = `Balance: ${balance.toFixed(4)} SOL`;
                            console.log(`Formatted wallet balance: ${balance.toFixed(4)} SOL`);
                        }
                    } else {
                        walletBalanceEl.textContent = 'Balance: Format error';
                        console.error('Balance parsed to NaN:', walletData.balance);
                    }
                } catch (e) {
                    console.error('Error parsing balance:', e, 'Raw value:', walletData.balance);
                    walletBalanceEl.textContent = 'Balance: Parse error';
                }
            } else {
                walletBalanceEl.textContent = 'Balance: 0 SOL (Empty wallet)';
                console.log('Wallet balance missing or null - treating as empty wallet');
            }
            
            // Update PnL if available
            if (walletData.pnl !== undefined && walletData.pnl !== null) {
                try {
                    const pnl = parseFloat(walletData.pnl);
                    if (!isNaN(pnl)) {
                        walletPnlEl.textContent = `PnL: ${pnl > 0 ? '+' : ''}${pnl.toFixed(4)} USDC`;
                        
                        // Apply color based on value
                        if (pnl > 0) {
                            walletPnlEl.classList.remove('negative');
                        } else if (pnl < 0) {
                            walletPnlEl.classList.add('negative');
                        }
                    } else {
                        walletPnlEl.textContent = 'PnL: --';
                    }
                } catch (e) {
                    console.error('Error parsing PnL:', e);
                    walletPnlEl.textContent = 'PnL: --';
                }
            } else {
                // Try to get total profits from arbitrage data if available
                const arbitrageProfitElem = document.getElementById('arbitrage-profit');
                if (arbitrageProfitElem && arbitrageProfitElem.textContent) {
                    // Extract the profit value from "Total Profit: $X.XX"
                    const profitMatch = arbitrageProfitElem.textContent.match(/\$([0-9.]+)/);
                    if (profitMatch && profitMatch[1]) {
                        walletPnlEl.textContent = `PnL: ${profitMatch[1]} USDC`;
                    } else {
                        walletPnlEl.textContent = 'PnL: 0.0000 USDC';
                    }
                } else {
                    walletPnlEl.textContent = 'PnL: 0.0000 USDC';
                }
            }
        }

        // Function to handle arbitrage trade updates
        function updateArbitrageTrades(data) {
            console.log('🛠️ Starting updateArbitrageTrades with data:', data);
            
            if (!data || !data.trades || !Array.isArray(data.trades)) {
                console.log('❌ No arbitrage trade data available');
                return;
            }
            
            console.log('🔍 Found trades array with length:', data.trades.length);

            const tableBody = document.getElementById('arbitrage-trades-table');
            const profitElement = document.getElementById('arbitrage-profit');
            const countElement = document.getElementById('arbitrage-count');
            const successRateElement = document.getElementById('arbitrage-success-rate');
            
            // Calculate total profit safely
            const totalProfit = typeof data.total_profit === 'number' ? 
                data.total_profit : 
                data.trades.reduce((sum, trade) => sum + (parseFloat(trade.realized_profit) || 0), 0);
            
            // Format with thousands separator and two decimal places
            const formattedProfit = new Intl.NumberFormat('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(totalProfit);
            
            // Update profit badge
            profitElement.textContent = `Total Profit: $${formattedProfit}`;
            profitElement.className = `badge ${totalProfit >= 0 ? 'badge-success' : 'badge-error'}`;
            
            // Calculate successful trades percentage if available
            const successfulTrades = data.successful_trades || 
                data.trades.filter(t => t.success).length;
            const totalTrades = data.trades.length;
            
            // Format count to show successful/total
            countElement.textContent = `Trades: ${successfulTrades}/${totalTrades}`;
            
            // Calculate and display success rate
            const successRate = totalTrades > 0 ? 
                Math.round((successfulTrades / totalTrades) * 100) : 0;
            successRateElement.textContent = `Success Rate: ${successRate}%`;
            
            // Store existing trade IDs to detect new trades
            const existingTradeIds = new Set();
            document.querySelectorAll('#arbitrage-trades-table tr[data-trade-id]').forEach(row => {
                existingTradeIds.add(row.dataset.tradeId);
            });
            
            // Clear the table
            tableBody.innerHTML = '';
            
            // If no trades, display a message
            if (data.trades.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="7" class="text-muted text-center">No arbitrage trades yet</td>';
                tableBody.appendChild(row);
                return;
            }
            
            // Sort trades by timestamp (newest first)
            const sortedTrades = [...data.trades].sort((a, b) => {
                return new Date(b.timestamp || b.time || 0) - new Date(a.timestamp || a.time || 0);
            });
            
            // Process each trade
            sortedTrades.forEach(trade => {
                const row = document.createElement('tr');
                
                // Format the timestamp - handle various timestamp formats
                let tradeTime;
                try {
                    tradeTime = new Date(trade.timestamp || trade.time);
                    if (isNaN(tradeTime.getTime())) {
                        console.warn('Invalid timestamp, using current time');
                        tradeTime = new Date();
                    }
                } catch (e) {
                    console.warn('Error parsing trade timestamp:', e);
                    tradeTime = new Date();
                }
                
                const timeFormatted = tradeTime.toLocaleTimeString([], {
                    hour: '2-digit', 
                    minute: '2-digit'
                });
                
                // Determine trade success status with fallbacks
                const isSuccess = trade.success === true;
                const hasError = !isSuccess && (trade.error || trade.error_message);
                const errorMessage = trade.error || trade.error_message || 'Unknown error occurred';
                
                // Create tooltip with error details
                const errorTooltip = hasError ? 
                    `<span class="tooltip" data-tooltip="${errorMessage.replace(/"/g, '&quot;')}">
                        <svg class="info-icon" viewBox="0 0 20 20">
                            <circle cx="10" cy="10" r="9" fill="none" stroke="currentColor" stroke-width="1.5"/>
                            <text x="10" y="14" text-anchor="middle" font-size="14" fill="currentColor">i</text>
                        </svg>
                    </span>` : '';
                
                // Determine status display
                const statusClass = isSuccess ? 'text-success' : 'text-error';
                const statusText = isSuccess ? '✅ Success' : '❌ Failed';
                
                // Create unique ID for this trade
                const tradeId = `${trade.timestamp || trade.time || Date.now()}-${trade.token_pair || ''}-${trade.buy_source || ''}-${trade.sell_source || ''}`;
                row.dataset.tradeId = tradeId;
                
                // Check if this is a new trade
                const isNewTrade = !existingTradeIds.has(tradeId);
                
                // Create the row
                row.innerHTML = `
                    <td>${timeFormatted}</td>
                    <td>${trade.token_pair || trade.pair || 'Unknown'}</td>
                    <td>${trade.buy_source || trade.buy_dex || 'N/A'}</td>
                    <td>${trade.sell_source || trade.sell_dex || 'N/A'}</td>
                    <td>$${parseFloat(trade.amount || 0).toFixed(2)}</td>
                    <td class="${statusClass}">$${parseFloat(trade.realized_profit || 0).toFixed(4)}</td>
                    <td class="${statusClass}">
                        ${statusText}${errorTooltip}
                    </td>
                `;
                
                // Add appropriate CSS classes for styling
                if (hasError) {
                    row.classList.add('has-error');
                }
                
                if (isNewTrade) {
                    row.classList.add(isSuccess ? 'new-success' : 'new-error');
                }
                
                tableBody.appendChild(row);
            });
        }

        // Listen for arbitrage trade updates from the server
        socket.on('arbitrage_update', function(data) {
            const tradeCount = data?.trades?.length || 0;
            const successCount = data?.trades?.filter(t => t.success).length || 0;
            const profit = data?.total_profit || 0;
            
            console.log(`📊 Received arbitrage_update: ${tradeCount} trades (${successCount} successful), $${profit.toFixed(2)} profit`);
            console.log('Full arbitrage_update data:', JSON.stringify(data));
            
            // Update the UI with the new trade data
            updateArbitrageTrades(data);
            
            // Debug: Log the table content after update
            setTimeout(() => {
                const tableBody = document.getElementById('arbitrage-trades-table');
                console.log('Arbitrage trades table after update:', tableBody.innerHTML);
            }, 100);
        });

        // Handle funds alerts from backend
        socket.on('funds_alert', function(alertData) {
            console.error('🚨 FUNDS ALERT received:', alertData);
            showFundsAlert(alertData);
        });
        
        // Handle general notifications
        socket.on('notification', function(notification) {
            console.log('🔔 Notification received:', notification);
            showNotification(notification);
        });
        
        // Toast notification system
        const toastContainer = document.getElementById('toast-container');
        
        // Function to show a toast notification
        function showToast(message, title = 'Notification', type = 'info', duration = 5000) {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            
            toast.innerHTML = `
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" aria-label="Close">&times;</button>
            `;
            
            toastContainer.appendChild(toast);
            
            // Force reflow to enable transition
            toast.offsetHeight; 
            toast.classList.add('show');
            
            // Setup close button
            const closeBtn = toast.querySelector('.toast-close');
            closeBtn.addEventListener('click', () => {
                closeToast(toast);
            });
            
            // Auto close after duration
            if (duration) {
                setTimeout(() => {
                    closeToast(toast);
                }, duration);
            }
            
            return toast;
        }
        
        function closeToast(toast) {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.remove();
            }, 300); // Wait for transition to complete
        }
        
        // Error toast for failed trades
        function showTradeErrorToast(errorMessage) {
            return showToast(errorMessage, 'Trade Failed', 'error', 8000);
        }
        
        // Funds Alert Functions
        function showFundsAlert(alertData) {
            console.log('🚨 Displaying funds alert:', alertData);
            
            const modal = document.getElementById('funds-alert-modal');
            const title = document.getElementById('alert-title');
            const message = document.getElementById('alert-message');
            const details = document.getElementById('alert-details');
            
            // Set title based on alert type
            if (alertData.type === 'startup_blocked') {
                title.textContent = '🚫 Bot Start Blocked';
            } else if (alertData.severity === 'critical') {
                title.textContent = '🚨 Critical: Insufficient Funds';
            } else {
                title.textContent = '⚠️ Low Funds Warning';
            }
            
            // Set message
            message.innerHTML = `<p><strong>${alertData.message}</strong></p>`;
            
            // Format details
            if (alertData.details) {
                let detailsHTML = '';
                
                if (alertData.details.sol_balance !== undefined) {
                    detailsHTML += `<p><strong>Current Balances:</strong></p>`;
                    detailsHTML += `<p>• SOL: ${alertData.details.sol_balance || 0} (Required: ${alertData.details.min_sol_required || 'N/A'})</p>`;
                    detailsHTML += `<p>• USDT: $${alertData.details.usdt_balance || 0} (Required: $${alertData.details.min_trading_balance || 'N/A'})</p>`;
                }
                
                if (alertData.details.issues && alertData.details.issues.length > 0) {
                    detailsHTML += `<p><strong>Issues:</strong></p>`;
                    alertData.details.issues.forEach(issue => {
                        detailsHTML += `<p style="color: var(--error);">❌ ${issue}</p>`;
                    });
                }
                
                if (alertData.details.warnings && alertData.details.warnings.length > 0) {
                    detailsHTML += `<p><strong>Warnings:</strong></p>`;
                    alertData.details.warnings.forEach(warning => {
                        detailsHTML += `<p style="color: var(--warning);">⚠️ ${warning}</p>`;
                    });
                }
                
                detailsHTML += `<p><strong>Wallet Address:</strong><br><code>CKu6VmahxjZAmWdEDWTvprckax3cJJQ4qwHpuuELkxgm</code></p>`;
                detailsHTML += `<p><strong>Action Required:</strong><br>${alertData.action_required || 'Fund your wallet before continuing'}</p>`;
                
                details.innerHTML = detailsHTML;
            }
            
            // Show modal
            modal.style.display = 'flex';
        }
        
        function closeFundsAlert() {
            const modal = document.getElementById('funds-alert-modal');
            modal.style.display = 'none';
        }
        
        function showNotification(notification) {
            const container = document.getElementById('notification-container');
            
            const notificationEl = document.createElement('div');
            notificationEl.className = `notification ${notification.type || 'info'}`;
            
            notificationEl.innerHTML = `
                <div class="notification-header">
                    <div class="notification-title">${notification.title || 'Notification'}</div>
                    <span class="notification-close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                </div>
                <div class="notification-message">${notification.message}</div>
            `;
            
            container.appendChild(notificationEl);
            
            // Auto-remove after 10 seconds unless it's persistent
            if (!notification.persistent) {
                setTimeout(() => {
                    if (notificationEl.parentElement) {
                        notificationEl.remove();
                    }
                }, 10000);
            }
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const fundsModal = document.getElementById('funds-alert-modal');
            const walletModal = document.getElementById('wallet-qr-modal');
            
            if (event.target === fundsModal) {
                closeFundsAlert();
            }
            if (event.target === walletModal) {
                closeWalletQR();
            }
        }
        
        // Expose functions globally for onclick handlers
        window.closeFundsAlert = closeFundsAlert;
        window.showFundsAlert = showFundsAlert;
        window.showNotification = showNotification;
    </script>
</body>
</html>
